{"config":{"output_file":null,"full_docs":false,"pub_only":true,"reachable_only":true,"distro_crate":false,"signatures":false,"borrow_data":false},"version":"0.19.0","compilation":{"directory":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0","program":"/home/thainguyen/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rls","arguments":["--crate-name","float_cmp","/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","--json=diagnostic-rendered-ansi","--crate-type","lib","--emit=dep-info,metadata","-C","embed-bitcode=no","-C","debuginfo=2","-C","metadata=aa2f1b7e34a7e8e2","-C","extra-filename=-aa2f1b7e34a7e8e2","--out-dir","/home/thainguyen/work/rust/rustlings/target/rls/debug/deps","-L","dependency=/home/thainguyen/work/rust/rustlings/target/rls/debug/deps","--extern","num_traits=/home/thainguyen/work/rust/rustlings/target/rls/debug/deps/libnum_traits-13911868d8cbdfa6.rmeta","--cap-lints","allow","--error-format=json","--sysroot","/home/thainguyen/.rustup/toolchains/stable-x86_64-unknown-linux-gnu"],"output":"/home/thainguyen/work/rust/rustlings/target/rls/debug/deps/libfloat_cmp-aa2f1b7e34a7e8e2.rmeta"},"prelude":{"crate_id":{"name":"float_cmp","disambiguator":[14979932666844021031,10368728098962763531]},"crate_root":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src","external_crates":[{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","num":1,"id":{"name":"std","disambiguator":[3329901521826220148,8779651902869174066]}},{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","num":2,"id":{"name":"core","disambiguator":[11533795067257537051,6600409280955634707]}},{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","num":3,"id":{"name":"compiler_builtins","disambiguator":[12614123221401343543,9564301585503608515]}},{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","num":4,"id":{"name":"rustc_std_workspace_core","disambiguator":[1785005413158388284,2453622026203223019]}},{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","num":5,"id":{"name":"alloc","disambiguator":[12957079427417428001,17718260667887668647]}},{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","num":6,"id":{"name":"libc","disambiguator":[10214993728156300765,14618204673916620187]}},{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","num":7,"id":{"name":"unwind","disambiguator":[12453517098623888364,4709794086161820998]}},{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","num":8,"id":{"name":"cfg_if","disambiguator":[12634510118091288440,7983944581587655387]}},{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","num":9,"id":{"name":"hashbrown","disambiguator":[14017342134866723280,9256858969587329629]}},{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","num":10,"id":{"name":"rustc_std_workspace_alloc","disambiguator":[7061025862014072460,14171357653989770935]}},{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","num":11,"id":{"name":"rustc_demangle","disambiguator":[2285728033677722481,16182084057206383065]}},{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","num":12,"id":{"name":"addr2line","disambiguator":[7305883247437987566,266452839079745451]}},{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","num":13,"id":{"name":"gimli","disambiguator":[13956229687295891598,15294992126055156716]}},{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","num":14,"id":{"name":"object","disambiguator":[931598532372339641,10024719927090962737]}},{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","num":15,"id":{"name":"miniz_oxide","disambiguator":[11150552510595322945,15608256962932530162]}},{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","num":16,"id":{"name":"adler","disambiguator":[4217706585212656622,592289864015908737]}},{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","num":17,"id":{"name":"panic_unwind","disambiguator":[2229008352226773351,3496425060661471051]}},{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","num":18,"id":{"name":"num_traits","disambiguator":[16953478490871110402,6657259888361939275]}}],"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":113,"byte_end":5343,"line_start":4,"line_end":128,"column_start":1,"column_end":36}},"imports":[{"kind":"Use","ref_id":{"krate":0,"index":7},"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":5148,"byte_end":5152,"line_start":116,"line_end":116,"column_start":21,"column_end":25},"alias_span":null,"name":"Ulps","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":19},"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":5191,"byte_end":5203,"line_start":119,"line_end":119,"column_start":24,"column_end":36},"alias_span":null,"name":"ApproxEqUlps","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":37},"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":5244,"byte_end":5257,"line_start":122,"line_end":122,"column_start":25,"column_end":38},"alias_span":null,"name":"ApproxOrdUlps","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":53},"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":5286,"byte_end":5294,"line_start":125,"line_end":125,"column_start":19,"column_end":27},"alias_span":null,"name":"ApproxEq","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":71},"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":5329,"byte_end":5342,"line_start":128,"line_end":128,"column_start":22,"column_end":35},"alias_span":null,"name":"ApproxEqRatio","value":"","parent":{"krate":0,"index":0}}],"defs":[{"kind":"Mod","id":{"krate":0,"index":0},"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":113,"byte_end":5343,"line_start":4,"line_end":128,"column_start":1,"column_end":36},"name":"","qualname":"::","value":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","parent":null,"children":[{"krate":0,"index":1},{"krate":0,"index":2},{"krate":0,"index":3},{"krate":0,"index":4},{"krate":0,"index":16},{"krate":0,"index":17},{"krate":0,"index":29},{"krate":0,"index":30},{"krate":0,"index":47},{"krate":0,"index":48},{"krate":0,"index":63},{"krate":0,"index":64},{"krate":0,"index":76}],"decl_id":null,"docs":" # float-cmp","sig":null,"attributes":[{"value":"/ # float-cmp","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":113,"byte_end":128,"line_start":4,"line_end":4,"column_start":1,"column_end":16}},{"value":"/","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":129,"byte_end":132,"line_start":5,"line_end":5,"column_start":1,"column_end":4}},{"value":"/ WARNING: comparing floating point numbers is very tricky and situation dependent, and","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":133,"byte_end":222,"line_start":6,"line_end":6,"column_start":1,"column_end":90}},{"value":"/ best avoided if at all possible. There is no panacea that \"just works\".","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":223,"byte_end":298,"line_start":7,"line_end":7,"column_start":1,"column_end":76}},{"value":"/","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":299,"byte_end":302,"line_start":8,"line_end":8,"column_start":1,"column_end":4}},{"value":"/ float-cmp defines traits for approximate comparison of floating point types which have fallen","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":303,"byte_end":400,"line_start":9,"line_end":9,"column_start":1,"column_end":98}},{"value":"/ away from exact equality due to the limited precision available within floating point","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":401,"byte_end":490,"line_start":10,"line_end":10,"column_start":1,"column_end":90}},{"value":"/ representations. Implementations of these traits are provided for `f32` and `f64` types.","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":491,"byte_end":583,"line_start":11,"line_end":11,"column_start":1,"column_end":93}},{"value":"/","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":584,"byte_end":587,"line_start":12,"line_end":12,"column_start":1,"column_end":4}},{"value":"/ The recommended go-to solution (although it may not be appropriate in all cases) is the","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":588,"byte_end":679,"line_start":13,"line_end":13,"column_start":1,"column_end":92}},{"value":"/ `approx_eq()` function in the `ApproxEq` trait.  An epsilon test is performed first, which","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":680,"byte_end":774,"line_start":14,"line_end":14,"column_start":1,"column_end":95}},{"value":"/ handles very small numbers, zeroes, and differing signs of very small numbers, considering","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":775,"byte_end":869,"line_start":15,"line_end":15,"column_start":1,"column_end":95}},{"value":"/ them equal if the difference is less than the given epsilon (e.g. f32::EPSILON). For larger","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":870,"byte_end":965,"line_start":16,"line_end":16,"column_start":1,"column_end":96}},{"value":"/ numbers, floating point representations are spaced further apart, and in these cases the ulps","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":966,"byte_end":1063,"line_start":17,"line_end":17,"column_start":1,"column_end":98}},{"value":"/ test comes to the rescue. Numbers are considered equal if the number of floating point","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":1064,"byte_end":1154,"line_start":18,"line_end":18,"column_start":1,"column_end":91}},{"value":"/ representations between them is below a specified bound (Ulps are a cardinal count of","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":1155,"byte_end":1244,"line_start":19,"line_end":19,"column_start":1,"column_end":90}},{"value":"/ floating point representations that separate two floating point numbers).","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":1245,"byte_end":1322,"line_start":20,"line_end":20,"column_start":1,"column_end":78}},{"value":"/","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":1323,"byte_end":1326,"line_start":21,"line_end":21,"column_start":1,"column_end":4}},{"value":"/ Several other traits are provided including `Ulps`, `ApproxEqUlps`, `ApproxOrdUlps`, and","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":1327,"byte_end":1419,"line_start":22,"line_end":22,"column_start":1,"column_end":93}},{"value":"/ `ApproxEqRatio`.","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":1420,"byte_end":1440,"line_start":23,"line_end":23,"column_start":1,"column_end":21}},{"value":"/","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":1441,"byte_end":1444,"line_start":24,"line_end":24,"column_start":1,"column_end":4}},{"value":"/ ## The problem","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":1445,"byte_end":1463,"line_start":25,"line_end":25,"column_start":1,"column_end":19}},{"value":"/","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":1464,"byte_end":1467,"line_start":26,"line_end":26,"column_start":1,"column_end":4}},{"value":"/ Floating point operations must round answers to the nearest representable number. Multiple","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":1468,"byte_end":1562,"line_start":27,"line_end":27,"column_start":1,"column_end":95}},{"value":"/ operations may result in an answer different from what you expect. In the following example,","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":1563,"byte_end":1659,"line_start":28,"line_end":28,"column_start":1,"column_end":97}},{"value":"/ the assert will fail, even though the printed output says \"0.45 == 0.45\":","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":1660,"byte_end":1737,"line_start":29,"line_end":29,"column_start":1,"column_end":78}},{"value":"/","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":1738,"byte_end":1741,"line_start":30,"line_end":30,"column_start":1,"column_end":4}},{"value":"/ ```should_panic","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":1742,"byte_end":1761,"line_start":31,"line_end":31,"column_start":1,"column_end":20}},{"value":"/   # extern crate float_cmp;","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":1762,"byte_end":1793,"line_start":32,"line_end":32,"column_start":1,"column_end":32}},{"value":"/   # use float_cmp::ApproxEq;","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":1794,"byte_end":1826,"line_start":33,"line_end":33,"column_start":1,"column_end":33}},{"value":"/   # fn main() {","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":1827,"byte_end":1846,"line_start":34,"line_end":34,"column_start":1,"column_end":20}},{"value":"/   let a = 0.15_f32 + 0.15_f32 + 0.15_f32;","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":1847,"byte_end":1892,"line_start":35,"line_end":35,"column_start":1,"column_end":46}},{"value":"/   let b = 0.1_f32 + 0.1_f32 + 0.25_f32;","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":1893,"byte_end":1936,"line_start":36,"line_end":36,"column_start":1,"column_end":44}},{"value":"/   println!(\"{} == {}\", a, b);","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":1937,"byte_end":1970,"line_start":37,"line_end":37,"column_start":1,"column_end":34}},{"value":"/   assert!(a==b)  // Fails, because they are not exactly equal","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":1971,"byte_end":2036,"line_start":38,"line_end":38,"column_start":1,"column_end":66}},{"value":"/   # }","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":2037,"byte_end":2046,"line_start":39,"line_end":39,"column_start":1,"column_end":10}},{"value":"/ ```","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":2047,"byte_end":2054,"line_start":40,"line_end":40,"column_start":1,"column_end":8}},{"value":"/","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":2055,"byte_end":2058,"line_start":41,"line_end":41,"column_start":1,"column_end":4}},{"value":"/ This fails because the correct answer to most operations isn't exactly representable, and so","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":2059,"byte_end":2155,"line_start":42,"line_end":42,"column_start":1,"column_end":97}},{"value":"/ your computer's processor chooses to represent the answer with the closest value it has","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":2156,"byte_end":2247,"line_start":43,"line_end":43,"column_start":1,"column_end":92}},{"value":"/ available. This introduces error, and this error can accumulate as multiple operations are","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":2248,"byte_end":2342,"line_start":44,"line_end":44,"column_start":1,"column_end":95}},{"value":"/ performed.","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":2343,"byte_end":2357,"line_start":45,"line_end":45,"column_start":1,"column_end":15}},{"value":"/","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":2358,"byte_end":2361,"line_start":46,"line_end":46,"column_start":1,"column_end":4}},{"value":"/ ## The solution","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":2362,"byte_end":2381,"line_start":47,"line_end":47,"column_start":1,"column_end":20}},{"value":"/","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":2382,"byte_end":2385,"line_start":48,"line_end":48,"column_start":1,"column_end":4}},{"value":"/ With `ApproxEq`, we can get the answer we intend:","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":2386,"byte_end":2439,"line_start":49,"line_end":49,"column_start":1,"column_end":54}},{"value":"/","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":2440,"byte_end":2443,"line_start":50,"line_end":50,"column_start":1,"column_end":4}},{"value":"/ ```","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":2444,"byte_end":2451,"line_start":51,"line_end":51,"column_start":1,"column_end":8}},{"value":"/   # extern crate float_cmp;","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":2452,"byte_end":2483,"line_start":52,"line_end":52,"column_start":1,"column_end":32}},{"value":"/   # use float_cmp::ApproxEq;","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":2484,"byte_end":2516,"line_start":53,"line_end":53,"column_start":1,"column_end":33}},{"value":"/   # fn main() {","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":2517,"byte_end":2536,"line_start":54,"line_end":54,"column_start":1,"column_end":20}},{"value":"/   let a = 0.15_f32 + 0.15_f32 + 0.15_f32;","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":2537,"byte_end":2582,"line_start":55,"line_end":55,"column_start":1,"column_end":46}},{"value":"/   let b = 0.1_f32 + 0.1_f32 + 0.25_f32;","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":2583,"byte_end":2626,"line_start":56,"line_end":56,"column_start":1,"column_end":44}},{"value":"/   println!(\"{} == {}\", a, b);","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":2627,"byte_end":2660,"line_start":57,"line_end":57,"column_start":1,"column_end":34}},{"value":"/   assert!(a.approx_eq(&b, 2.0 * ::std::f32::EPSILON, 2)) // They are equal, within 2 ulps","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":2661,"byte_end":2754,"line_start":58,"line_end":58,"column_start":1,"column_end":94}},{"value":"/   # }","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":2755,"byte_end":2764,"line_start":59,"line_end":59,"column_start":1,"column_end":10}},{"value":"/ ```","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":2765,"byte_end":2772,"line_start":60,"line_end":60,"column_start":1,"column_end":8}},{"value":"/","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":2773,"byte_end":2776,"line_start":61,"line_end":61,"column_start":1,"column_end":4}},{"value":"/ For most cases, I recommend you use a smallish integer for the `ulps` parameter (1 to 5","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":2777,"byte_end":2868,"line_start":62,"line_end":62,"column_start":1,"column_end":92}},{"value":"/ or so), and a similar small multiple of the floating point's EPSILON constant (1.0 to 5.0","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":2869,"byte_end":2962,"line_start":63,"line_end":63,"column_start":1,"column_end":94}},{"value":"/ or so), but there are *plenty* of cases where this is insufficient.","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":2963,"byte_end":3034,"line_start":64,"line_end":64,"column_start":1,"column_end":72}},{"value":"/","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":3035,"byte_end":3038,"line_start":65,"line_end":65,"column_start":1,"column_end":4}},{"value":"/ ## Some explanation","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":3039,"byte_end":3062,"line_start":66,"line_end":66,"column_start":1,"column_end":24}},{"value":"/","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":3063,"byte_end":3066,"line_start":67,"line_end":67,"column_start":1,"column_end":4}},{"value":"/ We use the term ULP (units of least precision, or units in the last place) to mean the","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":3067,"byte_end":3157,"line_start":68,"line_end":68,"column_start":1,"column_end":91}},{"value":"/ difference between two adjacent floating point representations (adjacent meaning that there is","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":3158,"byte_end":3256,"line_start":69,"line_end":69,"column_start":1,"column_end":99}},{"value":"/ no floating point number between them). This term is borrowed from prior work (personally I","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":3257,"byte_end":3352,"line_start":70,"line_end":70,"column_start":1,"column_end":96}},{"value":"/ would have chosen \"quanta\"). The size of an ULP (measured as a float) varies","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":3353,"byte_end":3433,"line_start":71,"line_end":71,"column_start":1,"column_end":81}},{"value":"/ depending on the exponents of the floating point numbers in question. That is a good thing,","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":3434,"byte_end":3529,"line_start":72,"line_end":72,"column_start":1,"column_end":96}},{"value":"/ because as numbers fall away from equality due to the imprecise nature of their representation,","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":3530,"byte_end":3629,"line_start":73,"line_end":73,"column_start":1,"column_end":100}},{"value":"/ they fall away in ULPs terms, not in absolute terms.  Pure epsilon-based comparisons are","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":3630,"byte_end":3722,"line_start":74,"line_end":74,"column_start":1,"column_end":93}},{"value":"/ absolute and thus don't map well to the nature of the additive error issue. They work fine","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":3723,"byte_end":3817,"line_start":75,"line_end":75,"column_start":1,"column_end":95}},{"value":"/ for many ranges of numbers, but not for others (consider comparing -0.0000000028","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":3818,"byte_end":3902,"line_start":76,"line_end":76,"column_start":1,"column_end":85}},{"value":"/ to +0.00000097).","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":3903,"byte_end":3923,"line_start":77,"line_end":77,"column_start":1,"column_end":21}},{"value":"/","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":3924,"byte_end":3927,"line_start":78,"line_end":78,"column_start":1,"column_end":4}},{"value":"/ ## Implementing these traits","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":3928,"byte_end":3960,"line_start":79,"line_end":79,"column_start":1,"column_end":33}},{"value":"/","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":3961,"byte_end":3964,"line_start":80,"line_end":80,"column_start":1,"column_end":4}},{"value":"/ You can implement `ApproxEq` for your own complex types. The trait and type parameter","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":3965,"byte_end":4054,"line_start":81,"line_end":81,"column_start":1,"column_end":90}},{"value":"/ notation can be a bit tricky, especially if your type is type parameterized around","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":4055,"byte_end":4141,"line_start":82,"line_end":82,"column_start":1,"column_end":87}},{"value":"/ floating point types.  So here is an example (you'll probably not specify the Copy trait","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":4142,"byte_end":4234,"line_start":83,"line_end":83,"column_start":1,"column_end":93}},{"value":"/ directly, but use some other NumTraits type floating point trait):","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":4235,"byte_end":4305,"line_start":84,"line_end":84,"column_start":1,"column_end":71}},{"value":"/","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":4306,"byte_end":4309,"line_start":85,"line_end":85,"column_start":1,"column_end":4}},{"value":"/ ```","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":4310,"byte_end":4317,"line_start":86,"line_end":86,"column_start":1,"column_end":8}},{"value":"/ use float_cmp::{Ulps, ApproxEq};","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":4318,"byte_end":4354,"line_start":87,"line_end":87,"column_start":1,"column_end":37}},{"value":"/","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":4355,"byte_end":4358,"line_start":88,"line_end":88,"column_start":1,"column_end":4}},{"value":"/ pub struct Vec2<F> {","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":4359,"byte_end":4383,"line_start":89,"line_end":89,"column_start":1,"column_end":25}},{"value":"/   pub x: F,","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":4384,"byte_end":4399,"line_start":90,"line_end":90,"column_start":1,"column_end":16}},{"value":"/   pub y: F,","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":4400,"byte_end":4415,"line_start":91,"line_end":91,"column_start":1,"column_end":16}},{"value":"/ }","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":4416,"byte_end":4421,"line_start":92,"line_end":92,"column_start":1,"column_end":6}},{"value":"/","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":4422,"byte_end":4425,"line_start":93,"line_end":93,"column_start":1,"column_end":4}},{"value":"/ impl<F: Ulps + ApproxEq<Flt=F> + Copy> ApproxEq for Vec2<F> {","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":4426,"byte_end":4491,"line_start":94,"line_end":94,"column_start":1,"column_end":66}},{"value":"/   type Flt = F;","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":4492,"byte_end":4511,"line_start":95,"line_end":95,"column_start":1,"column_end":20}},{"value":"/","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":4512,"byte_end":4515,"line_start":96,"line_end":96,"column_start":1,"column_end":4}},{"value":"/   fn approx_eq(&self, other: &Self,","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":4516,"byte_end":4555,"line_start":97,"line_end":97,"column_start":1,"column_end":40}},{"value":"/                epsilon: <F as ApproxEq>::Flt,","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":4556,"byte_end":4605,"line_start":98,"line_end":98,"column_start":1,"column_end":50}},{"value":"/                ulps: <<F as ApproxEq>::Flt as Ulps>::U) -> bool","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":4606,"byte_end":4673,"line_start":99,"line_end":99,"column_start":1,"column_end":68}},{"value":"/   {","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":4674,"byte_end":4681,"line_start":100,"line_end":100,"column_start":1,"column_end":8}},{"value":"/     self.x.approx_eq(&other.x, epsilon, ulps)","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":4682,"byte_end":4731,"line_start":101,"line_end":101,"column_start":1,"column_end":50}},{"value":"/       && self.y.approx_eq(&other.y, epsilon, ulps)","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":4732,"byte_end":4786,"line_start":102,"line_end":102,"column_start":1,"column_end":55}},{"value":"/   }","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":4787,"byte_end":4794,"line_start":103,"line_end":103,"column_start":1,"column_end":8}},{"value":"/ }","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":4795,"byte_end":4800,"line_start":104,"line_end":104,"column_start":1,"column_end":6}},{"value":"/ ```","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":4801,"byte_end":4808,"line_start":105,"line_end":105,"column_start":1,"column_end":8}},{"value":"/","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":4809,"byte_end":4812,"line_start":106,"line_end":106,"column_start":1,"column_end":4}},{"value":"/ ## Inspiration","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":4813,"byte_end":4831,"line_start":107,"line_end":107,"column_start":1,"column_end":19}},{"value":"/","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":4832,"byte_end":4835,"line_start":108,"line_end":108,"column_start":1,"column_end":4}},{"value":"/ This crate was inspired by this Random ASCII blog post:","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":4836,"byte_end":4895,"line_start":109,"line_end":109,"column_start":1,"column_end":60}},{"value":"/","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":4896,"byte_end":4899,"line_start":110,"line_end":110,"column_start":1,"column_end":4}},{"value":"/ [https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/)","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","byte_start":4900,"byte_end":5090,"line_start":111,"line_end":111,"column_start":1,"column_end":191}}]},{"kind":"Trait","id":{"krate":0,"index":7},"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps.rs","byte_start":5672,"byte_end":5676,"line_start":9,"line_end":9,"column_start":11,"column_end":15},"name":"Ulps","qualname":"::ulps::Ulps","value":"Ulps","parent":null,"children":[{"krate":0,"index":8},{"krate":0,"index":9}],"decl_id":null,"docs":" A trait for floating point numbers which computes the number of representable\n values or ULPs (Units of Least Precision) that separate the two given values.\n","sig":null,"attributes":[{"value":"/ A trait for floating point numbers which computes the number of representable","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps.rs","byte_start":5498,"byte_end":5579,"line_start":7,"line_end":7,"column_start":1,"column_end":82}},{"value":"/ values or ULPs (Units of Least Precision) that separate the two given values.","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps.rs","byte_start":5580,"byte_end":5661,"line_start":8,"line_end":8,"column_start":1,"column_end":82}}]},{"kind":"Type","id":{"krate":0,"index":8},"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps.rs","byte_start":5688,"byte_end":5689,"line_start":10,"line_end":10,"column_start":10,"column_end":11},"name":"U","qualname":"::ulps::Ulps::U","value":"type U: Copy + NumCast;","parent":{"krate":0,"index":7},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":9},"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps.rs","byte_start":5939,"byte_end":5943,"line_start":15,"line_end":15,"column_start":8,"column_end":12},"name":"ulps","qualname":"::ulps::Ulps::ulps","value":"pub fn ulps(&Self, &Self) -> <Self as Ulps>::U","parent":{"krate":0,"index":7},"children":[],"decl_id":null,"docs":" The number of representable values or ULPs (Units of Least Precision) that\n separate `self` and `other`.  The result `U` is an integral value, and will\n be zero if `self` and `other` are exactly equal.\n","sig":null,"attributes":[{"value":"/ The number of representable values or ULPs (Units of Least Precision) that","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps.rs","byte_start":5712,"byte_end":5790,"line_start":12,"line_end":12,"column_start":5,"column_end":83}},{"value":"/ separate `self` and `other`.  The result `U` is an integral value, and will","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps.rs","byte_start":5795,"byte_end":5874,"line_start":13,"line_end":13,"column_start":5,"column_end":84}},{"value":"/ be zero if `self` and `other` are exactly equal.","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps.rs","byte_start":5879,"byte_end":5931,"line_start":14,"line_end":14,"column_start":5,"column_end":57}}]},{"kind":"Trait","id":{"krate":0,"index":19},"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_eq.rs","byte_start":9896,"byte_end":9908,"line_start":10,"line_end":10,"column_start":11,"column_end":23},"name":"ApproxEqUlps","qualname":"::ulps_eq::ApproxEqUlps","value":"ApproxEqUlps","parent":null,"children":[{"krate":0,"index":20},{"krate":0,"index":21},{"krate":0,"index":22}],"decl_id":null,"docs":" ApproxEqUlps is a trait for approximate equality comparisons.\n The associated type Flt is a floating point type which implements Ulps, and is\n required so that this trait can be implemented for compound types (e.g. vectors),\n not just for the floats themselves.\n","sig":null,"attributes":[{"value":"/ ApproxEqUlps is a trait for approximate equality comparisons.","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_eq.rs","byte_start":9611,"byte_end":9676,"line_start":6,"line_end":6,"column_start":1,"column_end":66}},{"value":"/ The associated type Flt is a floating point type which implements Ulps, and is","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_eq.rs","byte_start":9677,"byte_end":9759,"line_start":7,"line_end":7,"column_start":1,"column_end":83}},{"value":"/ required so that this trait can be implemented for compound types (e.g. vectors),","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_eq.rs","byte_start":9760,"byte_end":9845,"line_start":8,"line_end":8,"column_start":1,"column_end":86}},{"value":"/ not just for the floats themselves.","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_eq.rs","byte_start":9846,"byte_end":9885,"line_start":9,"line_end":9,"column_start":1,"column_end":40}}]},{"kind":"Type","id":{"krate":0,"index":20},"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_eq.rs","byte_start":9920,"byte_end":9923,"line_start":11,"line_end":11,"column_start":10,"column_end":13},"name":"Flt","qualname":"::ulps_eq::ApproxEqUlps::Flt","value":"type Flt: Ulps;","parent":{"krate":0,"index":19},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":21},"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_eq.rs","byte_start":10283,"byte_end":10297,"line_start":18,"line_end":18,"column_start":8,"column_end":22},"name":"approx_eq_ulps","qualname":"::ulps_eq::ApproxEqUlps::approx_eq_ulps","value":"pub fn approx_eq_ulps(&Self, &Self, <Self::Flt as Ulps>::U) -> bool","parent":{"krate":0,"index":19},"children":[],"decl_id":null,"docs":" This method tests for `self` and `other` values to be approximately equal\n within ULPs (Units of Least Precision) floating point representations.\n Differing signs are always unequal with this method, and zeroes are only\n equal to zeroes. Use approx_eq() from the ApproxEq trait if that is more\n appropriate.\n","sig":null,"attributes":[{"value":"/ This method tests for `self` and `other` values to be approximately equal","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_eq.rs","byte_start":9936,"byte_end":10013,"line_start":13,"line_end":13,"column_start":5,"column_end":82}},{"value":"/ within ULPs (Units of Least Precision) floating point representations.","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_eq.rs","byte_start":10018,"byte_end":10092,"line_start":14,"line_end":14,"column_start":5,"column_end":79}},{"value":"/ Differing signs are always unequal with this method, and zeroes are only","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_eq.rs","byte_start":10097,"byte_end":10173,"line_start":15,"line_end":15,"column_start":5,"column_end":81}},{"value":"/ equal to zeroes. Use approx_eq() from the ApproxEq trait if that is more","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_eq.rs","byte_start":10178,"byte_end":10254,"line_start":16,"line_end":16,"column_start":5,"column_end":81}},{"value":"/ appropriate.","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_eq.rs","byte_start":10259,"byte_end":10275,"line_start":17,"line_end":17,"column_start":5,"column_end":21}}]},{"kind":"Method","id":{"krate":0,"index":22},"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_eq.rs","byte_start":10728,"byte_end":10742,"line_start":26,"line_end":26,"column_start":8,"column_end":22},"name":"approx_ne_ulps","qualname":"::ulps_eq::ApproxEqUlps::approx_ne_ulps","value":"pub fn approx_ne_ulps(&Self, &Self, <Self::Flt as Ulps>::U) -> bool","parent":{"krate":0,"index":19},"children":[],"decl_id":null,"docs":" This method tests for `self` and `other` values to be not approximately\n equal within ULPs (Units of Least Precision) floating point representations.\n Differing signs are always unequal with this method, and zeroes are only\n equal to zeroes. Use approx_eq() from the ApproxEq trait if that is more\n appropriate.\n","sig":null,"attributes":[{"value":"/ This method tests for `self` and `other` values to be not approximately","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_eq.rs","byte_start":10363,"byte_end":10438,"line_start":20,"line_end":20,"column_start":5,"column_end":80}},{"value":"/ equal within ULPs (Units of Least Precision) floating point representations.","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_eq.rs","byte_start":10443,"byte_end":10523,"line_start":21,"line_end":21,"column_start":5,"column_end":85}},{"value":"/ Differing signs are always unequal with this method, and zeroes are only","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_eq.rs","byte_start":10528,"byte_end":10604,"line_start":22,"line_end":22,"column_start":5,"column_end":81}},{"value":"/ equal to zeroes. Use approx_eq() from the ApproxEq trait if that is more","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_eq.rs","byte_start":10609,"byte_end":10685,"line_start":23,"line_end":23,"column_start":5,"column_end":81}},{"value":"/ appropriate.","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_eq.rs","byte_start":10690,"byte_end":10706,"line_start":24,"line_end":24,"column_start":5,"column_end":21}},{"value":"inline","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_eq.rs","byte_start":10711,"byte_end":10720,"line_start":25,"line_end":25,"column_start":5,"column_end":14}}]},{"kind":"Trait","id":{"krate":0,"index":37},"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_ord.rs","byte_start":14062,"byte_end":14075,"line_start":10,"line_end":10,"column_start":11,"column_end":24},"name":"ApproxOrdUlps","qualname":"::ulps_ord::ApproxOrdUlps","value":"ApproxOrdUlps: ApproxEqUlps","parent":null,"children":[{"krate":0,"index":38},{"krate":0,"index":39},{"krate":0,"index":40},{"krate":0,"index":41},{"krate":0,"index":42}],"decl_id":null,"docs":" ApproxOrdUlps is for sorting floating point values where approximate equality\n is considered equal.\n","sig":null,"attributes":[{"value":"/ ApproxOrdUlps is for sorting floating point values where approximate equality","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_ord.rs","byte_start":13945,"byte_end":14026,"line_start":8,"line_end":8,"column_start":1,"column_end":82}},{"value":"/ is considered equal.","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_ord.rs","byte_start":14027,"byte_end":14051,"line_start":9,"line_end":9,"column_start":1,"column_end":25}}]},{"kind":"Method","id":{"krate":0,"index":38},"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_ord.rs","byte_start":14371,"byte_end":14386,"line_start":15,"line_end":15,"column_start":8,"column_end":23},"name":"approx_cmp_ulps","qualname":"::ulps_ord::ApproxOrdUlps::approx_cmp_ulps","value":"pub fn approx_cmp_ulps(&Self, &Self, <<Self as ApproxEqUlps>::Flt as Ulps>::U)\n-> Ordering","parent":{"krate":0,"index":37},"children":[],"decl_id":null,"docs":" This method returns an ordering between `self` and `other` values\n if one exists, where Equal is returned if they are approximately\n equal within `ulps` floating point representations.  See module\n documentation for an understanding of `ulps`\n","sig":null,"attributes":[{"value":"/ This method returns an ordering between `self` and `other` values","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_ord.rs","byte_start":14096,"byte_end":14165,"line_start":11,"line_end":11,"column_start":5,"column_end":74}},{"value":"/ if one exists, where Equal is returned if they are approximately","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_ord.rs","byte_start":14170,"byte_end":14238,"line_start":12,"line_end":12,"column_start":5,"column_end":73}},{"value":"/ equal within `ulps` floating point representations.  See module","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_ord.rs","byte_start":14243,"byte_end":14310,"line_start":13,"line_end":13,"column_start":5,"column_end":72}},{"value":"/ documentation for an understanding of `ulps`","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_ord.rs","byte_start":14315,"byte_end":14363,"line_start":14,"line_end":14,"column_start":5,"column_end":53}}]},{"kind":"Method","id":{"krate":0,"index":39},"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_ord.rs","byte_start":14708,"byte_end":14722,"line_start":22,"line_end":22,"column_start":8,"column_end":22},"name":"approx_lt_ulps","qualname":"::ulps_ord::ApproxOrdUlps::approx_lt_ulps","value":"pub fn approx_lt_ulps(&Self, &Self, <<Self as ApproxEqUlps>::Flt as Ulps>::U)\n-> bool","parent":{"krate":0,"index":37},"children":[],"decl_id":null,"docs":" This method tests less than (for `self` < `other`), where values\n within `ulps` of each other are not less than.  See module\n documentation for an understanding of `ulps`.\n","sig":null,"attributes":[{"value":"/ This method tests less than (for `self` < `other`), where values","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_ord.rs","byte_start":14497,"byte_end":14565,"line_start":18,"line_end":18,"column_start":5,"column_end":73}},{"value":"/ within `ulps` of each other are not less than.  See module","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_ord.rs","byte_start":14570,"byte_end":14632,"line_start":19,"line_end":19,"column_start":5,"column_end":67}},{"value":"/ documentation for an understanding of `ulps`.","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_ord.rs","byte_start":14637,"byte_end":14686,"line_start":20,"line_end":20,"column_start":5,"column_end":54}},{"value":"inline","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_ord.rs","byte_start":14691,"byte_end":14700,"line_start":21,"line_end":21,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":40},"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_ord.rs","byte_start":15160,"byte_end":15174,"line_start":35,"line_end":35,"column_start":8,"column_end":22},"name":"approx_le_ulps","qualname":"::ulps_ord::ApproxOrdUlps::approx_le_ulps","value":"pub fn approx_le_ulps(&Self, &Self, <<Self as ApproxEqUlps>::Flt as Ulps>::U)\n-> bool","parent":{"krate":0,"index":37},"children":[],"decl_id":null,"docs":" This method tests less than or equal to (for `self` <= `other`)\n where values within `ulps` are equal.  See module documentation\n for an understanding of `ulps`.\n","sig":null,"attributes":[{"value":"/ This method tests less than or equal to (for `self` <= `other`)","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_ord.rs","byte_start":14959,"byte_end":15026,"line_start":31,"line_end":31,"column_start":5,"column_end":72}},{"value":"/ where values within `ulps` are equal.  See module documentation","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_ord.rs","byte_start":15031,"byte_end":15098,"line_start":32,"line_end":32,"column_start":5,"column_end":72}},{"value":"/ for an understanding of `ulps`.","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_ord.rs","byte_start":15103,"byte_end":15138,"line_start":33,"line_end":33,"column_start":5,"column_end":40}},{"value":"inline","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_ord.rs","byte_start":15143,"byte_end":15152,"line_start":34,"line_end":34,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":41},"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_ord.rs","byte_start":15630,"byte_end":15644,"line_start":48,"line_end":48,"column_start":8,"column_end":22},"name":"approx_gt_ulps","qualname":"::ulps_ord::ApproxOrdUlps::approx_gt_ulps","value":"pub fn approx_gt_ulps(&Self, &Self, <<Self as ApproxEqUlps>::Flt as Ulps>::U)\n-> bool","parent":{"krate":0,"index":37},"children":[],"decl_id":null,"docs":" This method tests greater than (for `self` > `other`)\n where values within `ulps` are not greater than.  See module\n documentation for an understanding of `ulps`\n","sig":null,"attributes":[{"value":"/ This method tests greater than (for `self` > `other`)","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_ord.rs","byte_start":15429,"byte_end":15486,"line_start":44,"line_end":44,"column_start":5,"column_end":62}},{"value":"/ where values within `ulps` are not greater than.  See module","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_ord.rs","byte_start":15491,"byte_end":15555,"line_start":45,"line_end":45,"column_start":5,"column_end":69}},{"value":"/ documentation for an understanding of `ulps`","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_ord.rs","byte_start":15560,"byte_end":15608,"line_start":46,"line_end":46,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_ord.rs","byte_start":15613,"byte_end":15622,"line_start":47,"line_end":47,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":42},"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_ord.rs","byte_start":16087,"byte_end":16101,"line_start":61,"line_end":61,"column_start":8,"column_end":22},"name":"approx_ge_ulps","qualname":"::ulps_ord::ApproxOrdUlps::approx_ge_ulps","value":"pub fn approx_ge_ulps(&Self, &Self, <<Self as ApproxEqUlps>::Flt as Ulps>::U)\n-> bool","parent":{"krate":0,"index":37},"children":[],"decl_id":null,"docs":" This method tests greater than or equal to (for `self` > `other`)\n where values within `ulps` are equal.  See module documentation\n for an understanding of `ulps`.\n","sig":null,"attributes":[{"value":"/ This method tests greater than or equal to (for `self` > `other`)","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_ord.rs","byte_start":15884,"byte_end":15953,"line_start":57,"line_end":57,"column_start":5,"column_end":74}},{"value":"/ where values within `ulps` are equal.  See module documentation","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_ord.rs","byte_start":15958,"byte_end":16025,"line_start":58,"line_end":58,"column_start":5,"column_end":72}},{"value":"/ for an understanding of `ulps`.","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_ord.rs","byte_start":16030,"byte_end":16065,"line_start":59,"line_end":59,"column_start":5,"column_end":40}},{"value":"inline","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_ord.rs","byte_start":16070,"byte_end":16079,"line_start":60,"line_end":60,"column_start":5,"column_end":14}}]},{"kind":"Trait","id":{"krate":0,"index":53},"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/eq.rs","byte_start":24395,"byte_end":24403,"line_start":10,"line_end":10,"column_start":11,"column_end":19},"name":"ApproxEq","qualname":"::eq::ApproxEq","value":"ApproxEq","parent":null,"children":[{"krate":0,"index":54},{"krate":0,"index":55},{"krate":0,"index":56}],"decl_id":null,"docs":" ApproxEq is a trait for approximate equality comparisons. The associated type Flt is a\n floating point type which implements Ulps, and is required so that this trait can be\n implemented for compound types (e.g. vectors),/ not just for the floats themselves.\n","sig":null,"attributes":[{"value":"/ ApproxEq is a trait for approximate equality comparisons. The associated type Flt is a","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/eq.rs","byte_start":24117,"byte_end":24207,"line_start":7,"line_end":7,"column_start":1,"column_end":91}},{"value":"/ floating point type which implements Ulps, and is required so that this trait can be","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/eq.rs","byte_start":24208,"byte_end":24296,"line_start":8,"line_end":8,"column_start":1,"column_end":89}},{"value":"/ implemented for compound types (e.g. vectors),/ not just for the floats themselves.","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/eq.rs","byte_start":24297,"byte_end":24384,"line_start":9,"line_end":9,"column_start":1,"column_end":88}}]},{"kind":"Type","id":{"krate":0,"index":54},"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/eq.rs","byte_start":24415,"byte_end":24418,"line_start":11,"line_end":11,"column_start":10,"column_end":13},"name":"Flt","qualname":"::eq::ApproxEq::Flt","value":"type Flt: Ulps;","parent":{"krate":0,"index":53},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":55},"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/eq.rs","byte_start":25127,"byte_end":25136,"line_start":23,"line_end":23,"column_start":8,"column_end":17},"name":"approx_eq","qualname":"::eq::ApproxEq::approx_eq","value":"pub fn approx_eq(&Self, &Self, Self::Flt, <Self::Flt as Ulps>::U) -> bool","parent":{"krate":0,"index":53},"children":[],"decl_id":null,"docs":" This method tests for `self` and `other` values to be approximately equal\n using two methods: epsilon and ulps.  If the values differ by less than the\n given epsilon, they will be considered equal. If the values differ by more\n than epsilon, but by less than the given ulps, they will also be considered\n equal. Otherwise they are unequal.","sig":null,"attributes":[{"value":"/ This method tests for `self` and `other` values to be approximately equal","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/eq.rs","byte_start":24431,"byte_end":24508,"line_start":13,"line_end":13,"column_start":5,"column_end":82}},{"value":"/ using two methods: epsilon and ulps.  If the values differ by less than the","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/eq.rs","byte_start":24513,"byte_end":24592,"line_start":14,"line_end":14,"column_start":5,"column_end":84}},{"value":"/ given epsilon, they will be considered equal. If the values differ by more","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/eq.rs","byte_start":24597,"byte_end":24675,"line_start":15,"line_end":15,"column_start":5,"column_end":83}},{"value":"/ than epsilon, but by less than the given ulps, they will also be considered","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/eq.rs","byte_start":24680,"byte_end":24759,"line_start":16,"line_end":16,"column_start":5,"column_end":84}},{"value":"/ equal. Otherwise they are unequal.","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/eq.rs","byte_start":24764,"byte_end":24802,"line_start":17,"line_end":17,"column_start":5,"column_end":43}},{"value":"/","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/eq.rs","byte_start":24807,"byte_end":24810,"line_start":18,"line_end":18,"column_start":5,"column_end":8}},{"value":"/ Note that very small values of differing signs may pass as equal under the","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/eq.rs","byte_start":24815,"byte_end":24893,"line_start":19,"line_end":19,"column_start":5,"column_end":83}},{"value":"/ epsilon method. The epsilon method is very useful for these cases and for","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/eq.rs","byte_start":24898,"byte_end":24975,"line_start":20,"line_end":20,"column_start":5,"column_end":82}},{"value":"/ handling zeroes. The ulps method helps for larger numbers where the spacing","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/eq.rs","byte_start":24980,"byte_end":25059,"line_start":21,"line_end":21,"column_start":5,"column_end":84}},{"value":"/ between floating point representations gets larger.","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/eq.rs","byte_start":25064,"byte_end":25119,"line_start":22,"line_end":22,"column_start":5,"column_end":60}}]},{"kind":"Method","id":{"krate":0,"index":56},"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/eq.rs","byte_start":25939,"byte_end":25948,"line_start":36,"line_end":36,"column_start":8,"column_end":17},"name":"approx_ne","qualname":"::eq::ApproxEq::approx_ne","value":"pub fn approx_ne(&Self, &Self, Self::Flt, <Self::Flt as Ulps>::U) -> bool","parent":{"krate":0,"index":53},"children":[],"decl_id":null,"docs":" This method tests for `self` and `other` values to be not approximately equal\n using two methods: epsilon and ulps.  If the values differ by less than the\n given epsilon, they will be considered equal. If the values differ by more\n than epsilon, but by less than the given ulps, they will also be considered\n equal. Otherwise they are unequal.","sig":null,"attributes":[{"value":"/ This method tests for `self` and `other` values to be not approximately equal","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/eq.rs","byte_start":25239,"byte_end":25320,"line_start":26,"line_end":26,"column_start":5,"column_end":86}},{"value":"/ using two methods: epsilon and ulps.  If the values differ by less than the","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/eq.rs","byte_start":25325,"byte_end":25404,"line_start":27,"line_end":27,"column_start":5,"column_end":84}},{"value":"/ given epsilon, they will be considered equal. If the values differ by more","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/eq.rs","byte_start":25409,"byte_end":25487,"line_start":28,"line_end":28,"column_start":5,"column_end":83}},{"value":"/ than epsilon, but by less than the given ulps, they will also be considered","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/eq.rs","byte_start":25492,"byte_end":25571,"line_start":29,"line_end":29,"column_start":5,"column_end":84}},{"value":"/ equal. Otherwise they are unequal.","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/eq.rs","byte_start":25576,"byte_end":25614,"line_start":30,"line_end":30,"column_start":5,"column_end":43}},{"value":"/","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/eq.rs","byte_start":25619,"byte_end":25622,"line_start":31,"line_end":31,"column_start":5,"column_end":8}},{"value":"/ Note that very small values of differing signs may pass as equal under the","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/eq.rs","byte_start":25627,"byte_end":25705,"line_start":32,"line_end":32,"column_start":5,"column_end":83}},{"value":"/ epsilon method. The epsilon method is very useful for these cases and for","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/eq.rs","byte_start":25710,"byte_end":25787,"line_start":33,"line_end":33,"column_start":5,"column_end":82}},{"value":"/ handling zeroes. The ulps method helps for larger numbers where the spacing","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/eq.rs","byte_start":25792,"byte_end":25871,"line_start":34,"line_end":34,"column_start":5,"column_end":84}},{"value":"/ between floating point representations gets larger.","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/eq.rs","byte_start":25876,"byte_end":25931,"line_start":35,"line_end":35,"column_start":5,"column_end":60}}]},{"kind":"Trait","id":{"krate":0,"index":71},"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ratio.rs","byte_start":30396,"byte_end":30409,"line_start":10,"line_end":10,"column_start":11,"column_end":24},"name":"ApproxEqRatio","qualname":"::ratio::ApproxEqRatio","value":"ApproxEqRatio: Div<Output = Self> + Sub<Output = Self> + Neg<Output = Self> + PartialOrd +\nZero + Sized + Copy","parent":null,"children":[{"krate":0,"index":72},{"krate":0,"index":73}],"decl_id":null,"docs":" ApproxEqRatio is a trait for approximate equality comparisons bounding the ratio\n of the difference to the larger.\n","sig":null,"attributes":[{"value":"/ ApproxEqRatio is a trait for approximate equality comparisons bounding the ratio","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ratio.rs","byte_start":30264,"byte_end":30348,"line_start":8,"line_end":8,"column_start":1,"column_end":85}},{"value":"/ of the difference to the larger.","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ratio.rs","byte_start":30349,"byte_end":30385,"line_start":9,"line_end":9,"column_start":1,"column_end":37}}]},{"kind":"Method","id":{"krate":0,"index":72},"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ratio.rs","byte_start":30759,"byte_end":30774,"line_start":16,"line_end":16,"column_start":8,"column_end":23},"name":"approx_eq_ratio","qualname":"::ratio::ApproxEqRatio::approx_eq_ratio","value":"pub fn approx_eq_ratio(&Self, &Self, Self) -> bool","parent":{"krate":0,"index":71},"children":[],"decl_id":null,"docs":" This method tests if `self` and `other` are nearly equal by bounding the\n difference between them to some number much less than the larger of the two.\n This bound is set as the ratio of the difference to the larger.\n","sig":null,"attributes":[{"value":"/ This method tests if `self` and `other` are nearly equal by bounding the","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ratio.rs","byte_start":30518,"byte_end":30594,"line_start":13,"line_end":13,"column_start":5,"column_end":81}},{"value":"/ difference between them to some number much less than the larger of the two.","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ratio.rs","byte_start":30599,"byte_end":30679,"line_start":14,"line_end":14,"column_start":5,"column_end":85}},{"value":"/ This bound is set as the ratio of the difference to the larger.","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ratio.rs","byte_start":30684,"byte_end":30751,"line_start":15,"line_end":15,"column_start":5,"column_end":72}}]},{"kind":"Method","id":{"krate":0,"index":73},"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ratio.rs","byte_start":31930,"byte_end":31945,"line_start":51,"line_end":51,"column_start":8,"column_end":23},"name":"approx_ne_ratio","qualname":"::ratio::ApproxEqRatio::approx_ne_ratio","value":"pub fn approx_ne_ratio(&Self, &Self, Self) -> bool","parent":{"krate":0,"index":71},"children":[],"decl_id":null,"docs":" This method tests if `self` and `other` are not nearly equal by bounding the\n difference between them to some number much less than the larger of the two.\n This bound is set as the ratio of the difference to the larger.\n","sig":null,"attributes":[{"value":"/ This method tests if `self` and `other` are not nearly equal by bounding the","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ratio.rs","byte_start":31671,"byte_end":31751,"line_start":47,"line_end":47,"column_start":5,"column_end":85}},{"value":"/ difference between them to some number much less than the larger of the two.","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ratio.rs","byte_start":31756,"byte_end":31836,"line_start":48,"line_end":48,"column_start":5,"column_end":85}},{"value":"/ This bound is set as the ratio of the difference to the larger.","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ratio.rs","byte_start":31841,"byte_end":31908,"line_start":49,"line_end":49,"column_start":5,"column_end":72}},{"value":"inline","span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ratio.rs","byte_start":31913,"byte_end":31922,"line_start":50,"line_end":50,"column_start":5,"column_end":14}}]}],"impls":[],"refs":[],"macro_refs":[],"relations":[{"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ulps_ord.rs","byte_start":14077,"byte_end":14089,"line_start":10,"line_end":10,"column_start":26,"column_end":38},"kind":"SuperTrait","from":{"krate":0,"index":19},"to":{"krate":0,"index":37}},{"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ratio.rs","byte_start":30412,"byte_end":30415,"line_start":10,"line_end":10,"column_start":27,"column_end":30},"kind":"SuperTrait","from":{"krate":2,"index":2125},"to":{"krate":0,"index":71}},{"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ratio.rs","byte_start":30433,"byte_end":30436,"line_start":10,"line_end":10,"column_start":48,"column_end":51},"kind":"SuperTrait","from":{"krate":2,"index":2115},"to":{"krate":0,"index":71}},{"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ratio.rs","byte_start":30454,"byte_end":30457,"line_start":10,"line_end":10,"column_start":69,"column_end":72},"kind":"SuperTrait","from":{"krate":2,"index":2137},"to":{"krate":0,"index":71}},{"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ratio.rs","byte_start":30479,"byte_end":30489,"line_start":11,"line_end":11,"column_start":7,"column_end":17},"kind":"SuperTrait","from":{"krate":2,"index":1807},"to":{"krate":0,"index":71}},{"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ratio.rs","byte_start":30492,"byte_end":30496,"line_start":11,"line_end":11,"column_start":20,"column_end":24},"kind":"SuperTrait","from":{"krate":18,"index":293},"to":{"krate":0,"index":71}},{"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ratio.rs","byte_start":30499,"byte_end":30504,"line_start":11,"line_end":11,"column_start":27,"column_end":32},"kind":"SuperTrait","from":{"krate":2,"index":2050},"to":{"krate":0,"index":71}},{"span":{"file_name":"/home/thainguyen/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/ratio.rs","byte_start":30507,"byte_end":30511,"line_start":11,"line_end":11,"column_start":35,"column_end":39},"kind":"SuperTrait","from":{"krate":2,"index":2055},"to":{"krate":0,"index":71}}]}